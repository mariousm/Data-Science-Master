---
title: "A1 - Preprocesado de datos"
author: "Mario Ubierna San Mamés"
date: '`r format(Sys.Date(),"%e de %B, %Y")`'
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

******
# Carga del archivo
******  
<p> Realizamos la lectura del fichero </p>
```{r}
df = read.csv(file="./data/fifa_raw.csv", sep=",", encoding="UTF-8") #Hay que hacer el encoding ya que de lo contrario leía mal los datos, por ejemplo Luis Suárez no identifica bien el caracter con tilde

df_copy = df # Realizamos una copia del dataframe original, para así modificar la copia de éste y mantener los datos originales
head(df_copy)
```

<p> Usamos la función str() para analizar el tipo de datos que R ha interpretado y observar los valores resumen de cada variable </p>
```{r}
str(df_copy)
```
<p> Como podemos observar en la anterior ejecución, no todos los datos están bien "categorizados", es decir, hay atributos como por ejmplo Nationality en el que ha categorizado la variable como character cuando lo mejor sería como factor, las fechas también están mal categorizadas, se las considera character cuando son Date, el dorsal de cada jugador se considera de tipo integer cuando debería ser un factor... 

Se irán resolviendo estos problemas a medida que vamos haciendo la práctica, ya que en este punto solo se nos pide cargar el fichero y examinar el tipo de datos.
</p>


******
# Verficar duplicación de registros
******
<p> Verificamos si hay registros duplicados con el valor ID. En caso de duplicación, seleccionamos el registro con menor número de NA en las variables 

Puede haber registros duplicados si tienen el mismo ID: </p>
```{r}
nRows = nrow(df_copy) # Número de registros (filas) que hay en el df
nUniques = length(unique(df_copy[["ID"]])) # Número de valores únicos de ID en el df

cat("El número de registros duplicados con el valor ID son: ", nRows - nUniques)
```
<p> Como podemos observar no hay duplicados por el campo ID, esto no significa que no pueda haber valores duplicados en otras columnas, es por ello que hacemos uso de la función duplicated() para saber si hay duplicados: </p>
```{r}
nUniques = length(duplicated(df_copy)) # Número de valores duplicados en el df

cat("El número de registros duplicados son: ", nRows - nUniques)
```



******
# Normalización de los datos cuantitativos
******

## Rating
<p> Verificar que la variable Rating esté entre 0 y 100. </p>
```{r}
nMinRating = min(df_copy$Rating) # Valor de rating mínimo
nMaxRating = max(df_copy$Rating) # Valor de rating máximo

cat("El valor mínimo de rating es: ", nMinRating)
cat("El valor máximo de rating es: ", nMaxRating)
```
<p> Como podemos observar el valor mínimo y máximo están dentro del intervalo [0,100]. </p>

## Height
<p> La variable Height se ha de expresar en cm con 3 dígitos sin decimales. Para facilitar la lectura y tratamiento del fichero deben ser numéricas, por lo tanto se debe quitar el símbolo en cm </p>
```{r}
# Método que nos permite hacer la conversión tanto para la variable Height como Weight
heiWeiFromCharToNumeric = function(value) {
  
  if (!is.na(value) & is.character(value)) {
    lstPairValues = strsplit(value, "[[:space:]]+")
    
    if (toupper(lstPairValues[[1]][2]) == "M") return(trunc(as.numeric(gsub(",", ".", lstPairValues[[1]][1])) * 100))
    if (toupper(lstPairValues[[1]][2]) == "CM") return(trunc(as.numeric(lstPairValues[[1]][1])))
    if (toupper(lstPairValues[[1]][2]) == "KG") return(trunc(as.numeric(gsub(",", ".", lstPairValues[[1]][1]))))
    if (toupper(lstPairValues[[1]][2]) == "GR") return(trunc(as.numeric(lstPairValues[[1]][1]) / 1000))
    
  } else {
    return(NA)
  }
   
}
                                
 df_copy$Height = sapply(df_copy$Height, heiWeiFromCharToNumeric)
 str(df_copy$Height)
```

## Weight
<p> La variable Weight se ha de expresar en kg con 3 dígitos sin decimales. Si hay decimales, se ha de truncar el valor. Para facilitar la lectura y tratamiento del fichero debn ser numéricas, por lo tanto se debe quitar el símbolo de kg. </p>
```{r}
# Hacemos uso de la función anterior para realizar la conversión
df_copy$Weight = sapply(df_copy$Weight, heiWeiFromCharToNumeric)
str(df_copy$Weight)
```

## Resumen
<p> En este apartado podemos observar de forma general los cambios realizados en este apartado </p>
```{r}
head(df_copy)
```



******
# Normalización de los datos cualitativos
******

## Name y Nationality
<p> Las variable Name y Nationality no han de tener espacios en blanco antes o después de su valor. El valor para estas variables han de ser mayúsculas en la primera letra de cada palabra, tal como "Lionel Messi" </p>
```{r}
# Método que elimina los espacios en blanco del principio y del final
trim = function (x) gsub("^\\s+|\\s+$", "", x)

# Método convierte el valor de entrada en un nuevo valor en el que la primera letra de cada palabra empieza por mayúscula.
firstLettertoUpperCase = function(value) {
  
  cValue = trim(value)
  lstValues = strsplit(cValue, "[^[a-zA-Z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u024F0-9]+]*")[[1]] #Código Unicode de los caracteres latín
  paste(toupper(substring(lstValues, 1,1)), tolower(substring(lstValues, 2)), sep="", collapse=" ")
}
```

```{r}
# Hacemos uso de la función anterior para que transforme el dato Name
df_copy$Name = sapply(df_copy$Name, firstLettertoUpperCase)
str(df_copy$Name)
```

```{r}
# Hacemos uso de la función anterior para que transforme el dato de Nationality
df_copy$Nationality = sapply(df_copy$Nationality, firstLettertoUpperCase)
str(df_copy$Nationality)
```

## Preffered_Foot
<p> La variable Preffered_Foot ha de tener los valores Left y Right que corresponde a los valores actuales de 1 y 2, respectivamente </p>
```{r}
df_copy$Preffered_Foot[df_copy$Preffered_Foot == 1] = "Left"
df_copy$Preffered_Foot[df_copy$Preffered_Foot == 2] = "Right"
str(df_copy$Preffered_Foot)
```

## Work_Rate
<p> La variable Work_Rate se basa en la combinación de dos de estas tres categorías: Low, Medium y High. Verificar que se cumple y en caso contrario, hay que corregirlo. Puedes encontrar los nombres de las categorías cortado con tres letras. </p>
```{r}
unique(df_copy$Work_Rate)
```
<p> Como podemos apreciar en la anterior ejecución vemos que se cumple, es decir, la variable Work_Rate se basa en una combinación de dos de esas tres categorías. Para que haya una uniformidad en los datos voy a cambiar el nombre acortado por el nombre no abreviado. </p>
```{r}
df_copy$Work_Rate = df$Work_Rate
# Método que completa las abreviaturas de la variable Work_Rate por su nombre completo
transformWorkRate = function(value) {
  lstValues = strsplit(value, "\\s+")
  cReturn = ""
  
  for (element in lstValues[[1]]) {
    if (toupper(element) == "LOW") cReturn = paste(cReturn, "Low", sep = "", collapse = NULL)
    if (toupper(element) == "MED" | toupper(element) == "MEDIUM") cReturn = paste(cReturn, "Medium", sep = "", collapse = NULL)
    if (toupper(element) == "HIG" | toupper(element) == "HIGH") cReturn = paste(cReturn, "High", sep = "", collapse = NULL)
    if (element == "/") cReturn = paste(cReturn, "/ ")
  }
  
  cReturn
}

df_copy$Work_Rate = sapply(df_copy$Work_Rate, transformWorkRate)
unique(df_copy$Work_Rate)
```
<p> Si comparamos los dos anteriores resultado vemos que hemos pasado de 11 categorías a 9, esto se debe a que había información abreviada que significa lo mismo que la información no abreviada. </p>

## Resumen
<p> En este apartado podemos observar de forma general los cambios realizados en este apartado </p>
```{r}
head(df_copy)
```



******
# Posibles inconsistencias y variables tipo fecha
******

## Club_Joining
<p> Verificar que la variable Club_Joining está en el rango de los años 1990 a 2017. En caso de haber algún registro que no cumpla la condición, indicar el número de registro, Name y Club_Joining. </p>
<p> Lo primero que debemos hacer es convertir las columnas Club_Joining y Contract_Expiry a tipo date, cabe destacar que de Contract_Expiry conocemos solo el año no el mes y el día en el que acaba el contrato, por lo tanto, según la FIFA los contratos se expiran el 30 de Junio del año X, es por ello que he considerado esa fecha como nueva fecha del Contract_Expiry: </p>
```{r}
df_copy$Club_Joining = as.Date(df_copy$Club_Joining, format = "%m/%d/%Y")
df_copy$Contract_Expiry = as.Date(paste("0630", as.character(df_copy$Contract_Expiry)), format = "%m%d%Y")

str(df_copy$Club_Joining)
str(df_copy$Contract_Expiry)
```

<p> Una vez que hemos convertido los atributos correspondietes a Date, puedemos realizar el ejercicio: </p>
```{r}
dMinClubJoining = min(df_copy$Club_Joining, na.rm = TRUE) # Fecha de Club_Joining mínima
dMaxClubJoining = max(df_copy$Club_Joining, na.rm = TRUE) # Fecha de Club_Joining máxima

cat("La fecha mínima de Club_Joining es: ", as.character(dMinClubJoining))
cat("La fecha máxima de Club_Joining es: ", as.character(dMaxClubJoining))

```
<p> Como podemos observar, la fecha mínima y la fecha máxima están dentro de los valores que se nos piden entre [1990,2017], es decir, desde 1990 hasta el 2017 incluido. Sin embargo, he tenido que usar na.rm = True, ya que hay un registro cuya fecha está vacía. Dicho registro es el siguiente: </p>
```{r}
summary(df_copy$Club_Joining)

df_copy[is.na(df_copy$Club_Joining), c("ID", "Name", "Club_Joining")]
```

<p> Por si acaso, si se condira que el 2017 no está incluido, tendríamos el siguiente número de jugadores que no lo cumplen: </p>
```{r}
cat("El número de jugadores que se unieron a un equipo a partir del 2017 es: ", nrow(df_copy[df_copy$Club_Joining >= as.Date("01/01/2017", format = "%m/%d/%Y"), c("ID", "Name", "Club_Joining")]))

head(df_copy[df_copy$Club_Joining >= as.Date("01/01/2017", format = "%m/%d/%Y"), c("ID", "Name", "Club_Joining")])
```

## Contract_Expiry >= Club_Joining?
<p> Verificar que el año de expiración del contrato (Contract_Expiry) no es inferior al año de inicio del contrato (Club_Joining). En caso de haber algún registro que no cumple la condición, indicar el número de registro, Name, Club_Joining y Contract_Expiry </p>
```{r}
df_copy[df_copy$Contract_Expiry < df_copy$Club_Joining, c("ID", "Name", "Club_Joining", "Contract_Expiry")]
```
<p> Como bien he mencionado antes, al calcular la fecha del Contract_Expiry consideramos hasta el 30 de Junio según dictamina la FIFA, entonces al hacer la consulta para saber si algún registro no cumple que el Contract_Expiry >= Club_Joining, observamos que no hay ningún registro que no la cumpla. </p>

## Revisar si la edad corresponde a la fecha de nacimiento
<p> Verificar que la edad (Age) en la fecha 1/1/2017 corresponde a la calculada con la fecha de nacimiento (Birth_Date). En caso de haber algún registro que no cumpla la condición, modificar la edad en función del valor obtenido con la fecha de nacimiento. </p>
<p> Lo primero de todo es transformar de character a Date la variable Birth_Date: </p>
```{r}
df_copy$Birth_Date = as.Date(df_copy$Birth_Date, format = "%m/%d/%Y")
str(df_copy$Birth_Date)
```

<p> Una vez cambiado el tipo de dato, podemos continuar con la resolución del ejercicio. Pero antes, a la hora de calcular los años puedes redondear hacia arriba o truncar el valor, he considerado que lo mejor es truncar el valor, ya que si redondeas hacia arriba estás atribuyendo una edad que todavía no ha cumplido por muy cerca que esté </p>
```{r}
# Método que calcula la edad a 1/1/2017
calculateAge = function(value) {
  fecha = as.Date("01/01/2017", "%m/%d/%Y")
  nAge = as.integer((fecha - value) / 365)
  nAge
}
```

<p> Calculamos las nuevas edades: </p>
```{r}
vAges = sapply(df_copy$Birth_Date, calculateAge) # Calculamos todas las edades
head(vAges) # Nuevas edades
```

<p> Comprobamos las edades pasadas: </p>
```{r}
head(df_copy$Age) # Edades pasadas
```

<p> Realizamos el cambio de las nuevas edades por las pasadas: </p>
```{r}
vIndex = df_copy$Age != vAges # Obtenemos dónde hay que realizar el cambio de la edad
df_copy$Age[vIndex] = vAges[vIndex] # Realizamos el cambio
head(df_copy$Age) # Resultado
```

## Resumen
<p> Podemos observar de forma general los cambios realizados en este apartado: </p>
```{r}
head(df_copy)
```



******
# Valores atípicos
******

## Height
<p> Comprobamos que no haya valores atípicos en el Height: </p>
```{r}
library(ggplot2) # Importamos la librería ggplot2
ggplot(mapping = aes(x=df_copy$Height)) + geom_density()
```

<p> Como podemos observar a priori no hay valores atípicos, ya que la altura se mueve en un intervalor adecuado. También podemos usar la función summary() y así que se vea de una forma numérica: </p>
```{r}
summary(df_copy$Height)
```

<p> Algo que destacar de la anterior ejecución, es que tenemos tres registros con valores NA, eso no significa que es un outlier, sino que más bien es un valor perdido, lo cual solucionaremos más adelante. Otra forma de ver valore atípicos es mediante la representación de un gráfico box plot: </p>
```{r}
boxplot(df_copy$Height, main="Height", color="gray")
boxplot.stats(df_copy$Height)$out
```

<p> Tal y como podemos ver sí que tenemos outliers, sin embargo no se tratan de valores anormales ya que es totalmente válido que una persona mida 155 cm que mida 207 cm. Por lo tanto, aunque hay outliers en el Height no podemos consideran que sean valores atípicos. </p> 

## Weight
<p> Comprobamos que no haya valores atípicos en el Wight: </p>
```{r}
ggplot(mapping = aes(x=df_copy$Weight)) + geom_density()
```
<p> Tal y como podemos observar, se produce uan distribución coherente, no tenemos picos con un peso muy pequeño o muy grande, por lo que a priori no vamos a tener valores centinelas. </p>
```{r}
summary(df_copy$Weight)
```

<p> Ejecutando summary() tenemos un resumen para esta variable, lo más significativo es que tenemos tres registros cuyo peso es NA, pero esto no son outliers, sino que son valores perdidos. </p>
```{r}
boxplot(df_copy$Weight, main="Weight", color="gray")
boxplot.stats(df_copy$Weight)$out
```
<p> Al igual que sucedía con la variable Height, a priori según el box plot tenemos outliers, pero analizando con más detenimiento, esos valores son totalmente coherentes, ya que una persona puede pesar de 48 Kg a 110 Kg sin ningún problema. </p>
